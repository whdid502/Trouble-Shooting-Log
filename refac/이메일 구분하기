1. 목표
 input에 들어간 텍스트가 이메일인지 구별하고 도메인을 판별해서 alret하는 함수를 만들려고 했습니다.
2. 미완성
 indexOf를 사용해 @의 개수를 파악한후, 조건문을 사용해 @가 잇어야만 이메일로 판정되게 했습니다. 이후 substring을 이용해 @이후의 .사이의 문자를 추출했습니다.

 function q5(){
   var email_input = $("#email_box").val();
   if(email_input.indexOf('@') > 0){
     var get_domain_start = email_input.indexOf('@');
     var get_domain_end = email_input.indexOf('.', get_domain_start+1);
     $("#show_email").text(email_input.substring(get_domain_start+1, get_domain_end))
     alert(email_input.substring(get_domain_start+1, get_domain_end));
   }
   else{
     alert('이메일이 아닙니다.');
   }
 };

3. 오류점
 하지만 abcd@abc.ab같은 정규이메일 타입은 잡아내지만 abcd@abcd같은 @는 포함돼잇으나, 이메일이 아닌 타입은 분류하지 못했습니다.
4. 해결법
이메일의 구분을 정규표현식을 사용한후 substring을 추출했습니다.

var email_input = $("#email_box").val();
var email_reg = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$/i;
if(email_input.match(email_reg) != null){
  var get_domain_start = email_input.indexOf('@');
  var get_domain_end = email_input.indexOf('.', get_domain_start+1);
  $("#show_email").text(email_input.substring(get_domain_start+1, get_domain_end))
  alert(email_input.substring(get_domain_start+1, get_domain_end));
}
else{
  alert('이메일이 아닙니다.');
}
};
